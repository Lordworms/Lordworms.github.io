
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>C++ -interview STL | Waiting for the dawn</title>
        <meta name="author" content="Yanxin Xiang">
        <meta name="description" content="">
        <meta name="keywords" content="">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <link rel="icon" href="https://i.ibb.co/1T1D1D9/QQ20230529-1.jpg">
        <script src="https://cdn.staticfile.org/vue/3.2.45/vue.global.prod.min.js"></script>
        <script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
        <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css">
        <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.2.1/css/all.min.css">
        
        <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
        
        
        <script src="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.js"></script>
        <script src="https://cdn.staticfile.org/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
        <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.css">
        
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="loading" style="height: 100vh; width: 100vw; left: 0; top: 0; position: fixed; display: flex; z-index: 2147483647; background: #fff; transition: opacity 0.3s ease-out; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; pointer-events: none">
    <div style="width: 50vmin; height: 50vmin; margin: auto; padding: 50px; border-radius: 50%; display: flex; border: solid 10px #a3ddfb">
        <div style="margin: auto; text-align: center">
            <h2>LOADING</h2>
            <p>加载过慢请开启缓存，浏览器默认开启</p>
            <img src="/images/loading.gif" style="height: 50px; border-radius: 0">
        </div>
    </div>
</div>

        <div id="layout">
            <transition name="into">
            <div id="main" v-show="showpage" style="display: -not-none">
                <nav id="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>WAITING FOR THE DAWN</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div :class="&quot;phone-menu &quot; + menushow" id="phone-menu">
        <div class="curtain" @click="menushow = !menushow" v-show="menushow"></div>
        <div class="title" @click="menushow = !menushow">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;WAITING FOR THE DAWN</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menushow">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>C++ -interview STL </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/18
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/tags/interview/" style="color: #ff7d73">interview</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/C/" style="color: #ffa2c4">C++</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>先来看所有的容器</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>容器</th>
<th>底层结构</th>
<th>时间复杂度</th>
<th>有无序</th>
<th>可不可重复</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>array</td>
<td>数组</td>
<td>随机读改O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>没啥好说的，就一个定长数组</td>
</tr>
<tr>
<td>vector</td>
<td>数组</td>
<td>随机读改O(1),尾部删除添加O(1),头部删除O(n)</td>
<td>无序</td>
<td>可重复</td>
<td>支持快速随机访问</td>
</tr>
</tbody>
</table>
</div>
<h2 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h2><p>我们知道，C++在堆上分配内存依赖的是new 和delete</p>
<p>那么new的时候在做什么呢？</p>
<p>先分配一块内存，然后再调用初始化函数</p>
<p>delete的时候也是一样，先调用析构函数，然后释放内存</p>
<p>那么allocator就是把这四个步骤进行了封装</p>
<pre><code class="lang-C++">#include &lt;new&gt;// for new
#include &lt;cstddef&gt; //  size_t
#include &lt;climits&gt; // for unit_max
#include &lt;iostream&gt; // for cerr
using namespace std;

namespace SLD &#123;
template &lt;class T&gt;
class allocator
&#123;
public:
    typedef T        value_type;
    typedef T*        pointer;
    typedef const T*    const_pointer;
    typedef T&amp;        reference;
    typedef const T&amp;    const_reference;
    typedef size_t        size_type;
    typedef ptrdiff_t    difference_type;

    template &lt;class U&gt;
    struct rebind
    &#123;
        typedef allocator&lt;U&gt; other;
    &#125;;

    //申请内存
    pointer allocate(size_type n, const void* hint = 0)
    &#123;
        T* tmp = (T*)(::operator new((size_t)(n * sizeof(T))));
        //operator new 和new operator是不同的
        if (!tmp)
            cerr &lt;&lt; &quot;out of memory&quot;&lt;&lt;endl;

        return tmp;

    &#125;

    //释放内存
    void deallocate(pointer p)
    &#123;
        ::operator delete(p);
    &#125;

    //构造
    void construct(pointer p, const T&amp; value)
    &#123;
        new(p) T1(value);
    &#125;

    //析构
    void destroy(pointer p)
    &#123;
        p-&gt;~T();
    &#125;

    //取地址
    pointer address(reference x)
    &#123;
        return (pointer)&amp;x;
    &#125;


    const_pointer const_address(const_reference x)
    &#123;
        return (const_pointer)&amp;x;
    &#125;

    size_type max_size() const 
    &#123;
        return size_type(UINT_MAX/sizeof(T));
    &#125;
&#125;;
&#125;
</code></pre>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>对于一条 vector<int>,其标准语句应该为</int></p>
<pre><code class="lang-C++">vetor&lt;int, allocator&lt;int&gt;&gt;
</code></pre>
<p>在头文件的定义中，写作如下的形式</p>
<pre><code class="lang-C++">template &lt;class _Ty, class _Alloc = allocator&lt;_Ty&gt;&gt;
class vector&#123;
    ...
protected:
    pointer _Myfirst;
    pointer _Mylast;
    pointer _Myend;
&#125;;
</code></pre>
<p>可以看到，vector拥有这三个迭代器，分别表示vetcor的开头、vetor的结尾、vector当前可用的结尾</p>
<p>vector的扩容是很消耗时间的，因为他需要以下三步</p>
<p>1.完全弃用现有内存空间，重新申请更大内存空间<br>2.将原内存空间中的数据移动到新的内存空间中去<br>3.将旧的内存空间释放</p>
<p>当扩容的时候，根据编译器的同，重新决定新容量的大小<br>如vs2017,扩容因子就是1.5</p>
<h2 id="2-list"><a href="#2-list" class="headerlink" title="2. list"></a>2. list</h2><p>没啥好说的，就是linux侵入式链表的逻辑</p>
<h2 id="3-queue和stack"><a href="#3-queue和stack" class="headerlink" title="3. queue和stack"></a>3. queue和stack</h2><p>更没啥好说的，给个指针实现就好了<br>默认情况下是由deque实现的</p>
<h2 id="4-deque"><a href="#4-deque" class="headerlink" title="4.deque"></a>4.deque</h2><p>deque的结构如下图所示，可以看到，deque是开辟了一段又一段的连续空间，然后对应有一个数组，里头存的是对应连续空间的首地址<br><img src="https://i.ibb.co/JK4TKc9/WX20230318-161551-2x.png" alt="avator"><br>deque有这样四个参数</p>
<pre><code class="lang-C++">template&lt;class T,...&gt;
struct __deque_iterator&#123;
    ...
    T* cur;
    T* first;
    T* last;
    map_pointer node;//map_pointer 等价于 T**
&#125;
</code></pre>
<p>1.cur：指向当前正在遍历的元素；</p>
<p>2.first：指向当前连续空间的首地址；</p>
<p>3.last：指向当前连续空间的末尾地址；</p>
<p>4.node：它是一个二级指针，用于指向 map 数组中存储的指向当前连续空间的指针。</p>
<p>deque中同样也保存了map数组的起始值和结束值指针</p>
<p><img src="https://i.ibb.co/q7cXdKt/WX20230318-175157-2x.png" alt="avator"></p>
<h2 id="5-priority-queue"><a href="#5-priority-queue" class="headerlink" title="5. priority_queue"></a>5. priority_queue</h2><p>内核是由最大最小堆实现的<br>堆，说白了就是个二叉树，对于最大堆有个特点就是每个节点都比自己的儿子节点要小<br>这里给一个rust版本的<br>(<a target="_blank" rel="noopener" href="https://github.com/Lordworms/interview_shit/blob/main/algorithm/src/heap/heap.rs">https://github.com/Lordworms/interview_shit/blob/main/algorithm/src/heap/heap.rs</a>)</p>
<p>对于堆来说，有以下三种操作</p>
<p>1.插入<br>插入到数组最后，然后向上调整</p>
<p>2.pop<br>把最后一个元素和堆顶元素交换，之后向下调整</p>
<p>3.重构<br>从后往前向上调整或者从前往后向下调整</p>
<h2 id="6-map-set"><a href="#6-map-set" class="headerlink" title="6.map,set"></a>6.map,set</h2><p>都由红黑树实现<br>红黑树的性质<br>1.每个节点要么是黑色，要么是红色。<br>2.根节点是黑色。<br>3.每个叶子节点（NIL）是黑色。<br>4.每个红色结点的两个子结点一定都是黑色。<br>5.任意一结点到每个叶子结点的路径都包含数量相同的黑结点<br>6.根到叶子结点的最长路径不超过最短路径的两倍</p>
<p>红黑树并不是完美平衡二叉树，但是他是完美黑色节点平衡二叉树</p>
<p>有三种操作能让红黑树自平衡<br>旋转的意义就是把大一些的子树上移，小一些的子树下移<br>1.左旋</p>
<p>当前节点的左子树<br><img src="https://i.ibb.co/LPQBCyY/2392382-a95db442f1b47f8a.webp" alt="avator"><br>2.右旋<br><img src="https://i.ibb.co/bK3JD9Q/2392382-0676a8e2a12e2a0b.webp" alt="avator"><br>3.变色<br>不用介绍惹</p>
<p>支持这些操作:<br>1.查找</p>
<p>2.插入</p>
<p>a.插入节点并把其设置为红色<br>b.重新染色并且通过自旋来解决冲突<br>那么包含以下四种场景<br>a. 当前节点为根</p>
<p>把当前节点染成黑色</p>
<p>b. 当前节点的叔叔节点为红色</p>
<p>对当前节点的叔叔和父亲节点重新染色</p>
<p>c. 当前节点的叔叔节点是黑色(三角形)<br>旋转其父亲节点(相反方向)</p>
<p><img src="https://i.ibb.co/2MN98Bv/WX20230318-213416-2x.png" alt="avator"></p>
<p>d. 当前节点的叔叔节点是黑色(直线情况)</p>
<p>旋转其祖先节点(相反方向) 并对父亲和祖先节点重新染色<br><img src="https://i.ibb.co/P9ZKWrs/WX20230318-213644-2x.png" alt="avator"></p>
<p>3.删除<br>对于删除，有这几种情况<br>a. transplant</p>
<p>用python代码整,很好懂</p>
<pre><code class="lang-Python">def transplant(self,u,v):
    if u.parent==None:
        self.root=v
    elif u==u.parent.left:
        u.parent.left=v
    else:
        u.parent.right=v
    v.p=u.p
</code></pre>
<p>b. delete</p>
<p>(1)left is nil<br> 只需要调用transplant然后重新染色就好了</p>
<p>(2)right is nil</p>
<p> 只需要调用transplant然后重新染色就好了</p>
<p>(3)neither is nil</p>
<p>找对应的右子树的最小节点，然后把该节点当成根，然后删除对应节点，接入本来的节点的父节点中去，并修改颜色</p>
<p>c. delete_fixup<br>修改对应颜色</p>
<h2 id="6-unordered-map的扩张的方式"><a href="#6-unordered-map的扩张的方式" class="headerlink" title="6.unordered_map的扩张的方式"></a>6.unordered_map的扩张的方式</h2><p>在C++ STL中，unordered_map是使用哈希表来实现的，其扩张方式如下：</p>
<p>1.当插入新元素时，如果元素数量已经达到了负载因子(load factor)的阈值，就需要对哈希表进行扩张操作。</p>
<p>2.扩张操作会创建一个新的哈希表，将旧哈希表中的所有元素重新哈希到新哈希表中。</p>
<p>3.扩张后的新哈希表的大小为原哈希表大小的两倍，并重新计算新的负载因子阈值。</p>
<p>4.扩张操作的具体实现可以是：分配新哈希表的空间，将旧哈希表中的所有元素遍历并重新插入到新哈希表中。</p>
<h2 id="7-unordered-map解决冲突的方式"><a href="#7-unordered-map解决冲突的方式" class="headerlink" title="7.unordered_map解决冲突的方式"></a>7.unordered_map解决冲突的方式</h2><p>1.链表法（Separate Chaining）：将相同哈希值的元素链接到同一个链表中。当发生哈希冲突时，新元素会被插入到对应的链表中。</p>
<p>2.开放地址法（Open Addressing）：在哈希表中找到一个空闲的位置来存储发生哈希冲突的元素。常见的开放地址法有线性探测、二次探测和双重哈希等。</p>
<p>3.建立更多的桶（Bucket）：增加哈希表的大小，通过增加桶的数量来减少哈希冲突的概率。</p>
<p>在std::unordered_map中，默认使用链表法来解决哈希冲突。当发生哈希冲突时，新元素会被插入到链表的尾部。然而，在某些情况下，链表法可能会导致性能下降，因为链表的遍历和访问操作可能会增加缓存不命中的数量。在这种情况下，可以考虑使用其他的解决哈希冲突的方法，例如开放地址法或二叉树等。可以通过自定义哈希函数和比较函数来实现这些解决哈希冲突的方法。</p>
<p>reference from (<a target="_blank" rel="noopener" href="https://blog.csdn.net/vjhghjghj/article/details/88647336/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0--blog-78110973.pc_relevant_3mothn_strategy_recovery&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=2">https://blog.csdn.net/vjhghjghj/article/details/88647336/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0--blog-78110973.pc_relevant_3mothn_strategy_recovery&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=2</a>)</p>
<p>(reference from <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a>)</p>

    </div>
    
    
    
    
    
    <div id="comment">
        <div id="waline-container"></div>
    </div>
    
    
    
</div>

                <footer id="footer">
    <div class="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Waiting for the dawn
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Yanxin Xiang
        </div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp; <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>

            </div>
            </transition>
            <div id="showimg">
                <img id="showimg-content">
            </div>
        </div>
        <script src="/js/functions.js"></script>
<script src="/js/particlex.js"></script>




<script src="https://cdn.staticfile.org/waline/2.14.7/waline.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.14.7/waline.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.14.7/waline-meta.min.css">
<script>
    Waline.init({
        el: "#waline-container",
        serverURL: "https://blog-comment-one-pi.vercel.app",
        commentCount: true,
        pageview: false,
        emoji: ["https://unpkg.com/@waline/emojis@1.2.0/weibo","https://unpkg.com/@waline/emojis@1.2.0/alus","https://unpkg.com/@waline/emojis@1.2.0/bilibili","https://unpkg.com/@waline/emojis@1.2.0/qq","https://unpkg.com/@waline/emojis@1.2.0/tieba","https://unpkg.com/@waline/emojis@1.2.0/tw-emoji"],
        meta: ["nick","mail","link"],
        requiredMeta: ["nick"],
        lang: "zh-CN",
        wordLimit: 0,
        pageSize: "10",
        login: "enable",
        locale: {},
    });
</script>




    </body>
</html>
